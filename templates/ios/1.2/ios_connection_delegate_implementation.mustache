//
//  ConnectionDelegate.m
//  {{{projectName}}}
//  Version: {{{version}}}
//
//  Created by Eli Kohen
//  Copyright (c) 2013 EKGDev. All rights reserved.
//

#import "ConnectionDelegate.h"
#import "ServiceHelper.h"

@interface ConnectionDelegate (){
}

@property (nonatomic, strong) NSMutableData *receivedData;
@property (nonatomic, strong) NSURLResponse *receivedResponse;
@property (nonatomic, strong) NSError *error;
@property (nonatomic, strong) NSURLConnection *connection;

@property (nonatomic, weak) id<ServiceDelegate> delegate;
@property (nonatomic) NSInteger tag;
@property (copy) ProcessDataBlock processDataBlock;

@end

@implementation ConnectionDelegate


#pragma mark - Public methods

- (void) startConnectionWithRequest: (NSURLRequest*) request tag: (NSInteger) tag delegate: (id<ServiceDelegate>) delegate andProcessDataBlock: (ProcessDataBlock) dataBlock {
	self.receivedData = [[NSMutableData alloc] init];
	self.receivedResponse = nil;
	self.connection = nil;
	self.delegate = delegate;
	self.processDataBlock = dataBlock;
	self.tag = tag;
	
	if([[ServiceHelper sharedInstance] checkConnection]){
		self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];
		[self.connection start];
	}
	else{
		[delegate onTaskNoConnection:tag];
	}
}

- (void) cancel{
	if(self.connection){
		[self.connection cancel];
	}
	self.connection = nil;
	self.receivedData = nil;
	self.receivedResponse = nil;
	self.error = nil;
}

#pragma mark - Private methods

- (void) didFinishLoading{
	ServiceResponse *result = nil;
	NSError *error = self.error;
	if(!error){
		if(self.receivedData && self.receivedData.length > 0){
			id processedData = self.processDataBlock(self.receivedData, &error);
			result = [[ServiceResponse alloc] initWithData:processedData andResponse:self.receivedResponse];
		} else{
			result = [[ServiceResponse alloc] initWithData:nil andResponse:self.receivedResponse];
		}
	}
	
	if (!error && _delegate) {
		if([[ServiceHelper sharedInstance] checkCorrectResponse:result serviceTag: self.tag]){
			[_delegate onTaskSuccess:result withTag:self.tag];
		}
		else{
			[_delegate onTaskFailed:result withTag:self.tag];
		}
	}
	else if (error && _delegate) {
		[_delegate onTaskError:error withTag:self.tag];
	}
	self.connection = nil;
	self.receivedData = nil;
	self.receivedResponse = nil;
	self.error = nil;
}

#pragma mark -  NSURLConnectionDelegate

#ifdef NO_SSL_VALIDATION
- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpace {
    
    return [protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust];
}

- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge {
    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust])
		[challenge.sender useCredential:[NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];
    
    [challenge.sender continueWithoutCredentialForAuthenticationChallenge:challenge];
}
#endif

- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
    
    self.receivedData = nil;
    self.receivedResponse = nil;
    
    NSLog(@"Connection failed! Error - %@ %@",
          [error localizedDescription],
          [[error userInfo] objectForKey:NSURLErrorFailingURLStringErrorKey]);
    
    self.error = error;
	[self didFinishLoading];
}

- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
	
	self.receivedResponse = response;
    
    [self.receivedData setLength:0];
}

- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
    
    [self.receivedData appendData:data];
}

- (void)connectionDidFinishLoading:(NSURLConnection *)connection {
    
	[self didFinishLoading];
}

@end
